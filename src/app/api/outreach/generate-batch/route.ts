import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { generateOutreachDraft } from "@/lib/draft-generator";

export const maxDuration = 300; // 5 min for batch

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { chefIds } = body as { chefIds: string[] };

  if (!chefIds || chefIds.length === 0) {
    return NextResponse.json({ error: "chefIds is required" }, { status: 400 });
  }

  const chefs = await prisma.chef.findMany({
    where: { id: { in: chefIds } },
    include: {
      accolades: { orderBy: { year: "desc" } },
      careerEntries: { orderBy: { startYear: "desc" } },
      contact: true,
      newsItems: {
        include: { newsItem: true },
        orderBy: { newsItem: { publishedAt: "desc" } },
        take: 5,
      },
    },
  });

  const sender = await prisma.senderSettings.findFirst();
  const outreachSettings = await prisma.outreachSettings.findFirst();

  const senderInfo = {
    name: sender?.name || "",
    title: sender?.title || "",
    company: sender?.company || "",
  };

  const config = {
    purpose: outreachSettings?.purpose || "We want to connect one-on-one to understand what top chefs look for in an assistant, what tools and support they rely on, and what's missing.",
    tone: outreachSettings?.tone || "warm",
    maxWords: outreachSettings?.maxWords || 150,
  };

  const results: { chefId: string; chefName: string; draftId: string; confidence: string; error?: string }[] = [];

  for (const chef of chefs) {
    try {
      const result = await generateOutreachDraft(chef, senderInfo, config);

      const draft = await prisma.outreachDraft.create({
        data: {
          chefId: chef.id,
          toEmail: chef.contact?.email || chef.contact?.agentEmail || null,
          subject: result.subject,
          body: result.body,
          status: "drafted",
          isAutoGenerated: true,
          dataPointsUsed: JSON.stringify(result.dataPointsUsed),
          confidence: result.confidence,
        },
      });

      results.push({
        chefId: chef.id,
        chefName: chef.name,
        draftId: draft.id,
        confidence: result.confidence,
      });

      // Rate limit: 500ms delay between calls
      if (chefs.indexOf(chef) < chefs.length - 1) {
        await new Promise((r) => setTimeout(r, 500));
      }
    } catch (err) {
      results.push({
        chefId: chef.id,
        chefName: chef.name,
        draftId: "",
        confidence: "low",
        error: (err as Error).message,
      });
    }
  }

  return NextResponse.json({
    results,
    total: chefs.length,
    success: results.filter((r) => !r.error).length,
    failed: results.filter((r) => r.error).length,
  });
}
