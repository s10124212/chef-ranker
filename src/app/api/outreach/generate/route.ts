import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { generateOutreachDraft } from "@/lib/draft-generator";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { chefId, previousDraftId } = body as { chefId: string; previousDraftId?: string };

  if (!chefId) {
    return NextResponse.json({ error: "chefId is required" }, { status: 400 });
  }

  const chef = await prisma.chef.findUnique({
    where: { id: chefId },
    include: {
      accolades: { orderBy: { year: "desc" } },
      careerEntries: { orderBy: { startYear: "desc" } },
      contact: true,
      newsItems: {
        include: { newsItem: true },
        orderBy: { newsItem: { publishedAt: "desc" } },
        take: 5,
      },
    },
  });

  if (!chef) {
    return NextResponse.json({ error: "Chef not found" }, { status: 404 });
  }

  const sender = await prisma.senderSettings.findFirst();
  const outreachSettings = await prisma.outreachSettings.findFirst();

  const senderInfo = {
    name: sender?.name || "",
    title: sender?.title || "",
    company: sender?.company || "",
  };

  const config = {
    purpose: outreachSettings?.purpose || "We want to connect one-on-one to understand what top chefs look for in an assistant, what tools and support they rely on, and what's missing.",
    tone: outreachSettings?.tone || "warm",
    maxWords: outreachSettings?.maxWords || 150,
  };

  // Get previous draft body if regenerating
  let previousDraftBody: string | undefined;
  if (previousDraftId) {
    const prev = await prisma.outreachDraft.findUnique({ where: { id: previousDraftId } });
    if (prev) previousDraftBody = prev.body;
  }

  try {
    const result = await generateOutreachDraft(chef, senderInfo, config, previousDraftBody);

    // Save draft
    const draft = await prisma.outreachDraft.create({
      data: {
        chefId: chef.id,
        toEmail: chef.contact?.email || chef.contact?.agentEmail || null,
        subject: result.subject,
        body: result.body,
        status: "drafted",
        isAutoGenerated: true,
        dataPointsUsed: JSON.stringify(result.dataPointsUsed),
        confidence: result.confidence,
        previousDraftId: previousDraftId || null,
      },
    });

    return NextResponse.json({
      draft,
      dataPointsUsed: result.dataPointsUsed,
      confidence: result.confidence,
    });
  } catch (err) {
    return NextResponse.json(
      { error: (err as Error).message },
      { status: 500 }
    );
  }
}
